> [박성범님의 공룡책으로 정리하는 운영체제](https://parksb.github.io/articles.html)를 보고 정리

# [Ch.1](https://parksb.github.io/article/5.html)
**운영체제**는 컴퓨터의 하드웨어를 관리하고, 하드웨어 - 소프트웨어 - 사용자를 매개하는 프로그램이다.  
커널이 운영체제의 핵심이며 커널이 동일하면 같은 운영체제로 취급된다.

## 역할
- User view : 운영체제는 사용자들이 자원을 공평하게 사용하도록 한다.
- System view : 시스템에게 운영체제는 자원 할당자로, 자원을 관리하는 제어 프로그램으로서 동작한다.

## Boot loader
컴퓨터 부팅시 **bootstrap program**이 실행된다. 
- 컴퓨터의 ROM이나 EEPROM에 저장되어 있고, 펌웨어라고 불린다.
- 시스템을 초기화하며 부트로더를 실행하게 되는데, 부트로더는 운영체제를 실행한다.

## Interrupt
**인터럽트**란 컴퓨터에서 신호를 보내 이벤트 발생을 알리는 작업이다. 여러 작업을 동시에 처리하는데 당장 처리할 작업이 있는 경우 현재 실행 중인 작업을 중단하여 인터럽트를 발생시킨다. 인터럽트 벡터에 메모리상의 위치를 저장하는데, file I/O 작업이 하드코딩되어 있다. 인터럽트를 처리하면 CPU는 원래의 작업으로 돌아온다.
- 소프트웨어 인터럽트 : 시스템 콜로 인터럽트를 발생시킨다.
- 하드웨어 인터럽트 : 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킨다.

## Storage 
커널은 Executor를 통해 프로그램을 실행하는데, executor는 storage에서 실행 파일을 가져와 메모리에 할당시킨다. 모든 프로그램은 메인 메모리(RAM)에 로드되어 실행된다.  
- 비휘발성 storage : SSD 같은 보조기억장치
- 휘발성 storage : RAM, Cache, Registers
Hibernate는 컴퓨터가 절전모드에 진입시 메모리의 모든 데이터를 보조기억장치에 덤프하고, 절전모드가 끝나면 데이터를 다시 불러오는 과정이다.

## Direct Memory Access
- *PIO(Programmed I/O)*: 이전에 장치 데이터는 CPU를 거쳐 메모리에 로드되어 처리하였다.
- CPU 자원 사용을 줄이기 위해 DMA를 통해 장치와 메모리를 직접 연결하여 사용한다. 장치 데이터는 장치 컨트롤러에 의해 직접 메모리에 전달되고, CPU상에서는 데이터 이동이 완료되었다는 인터럽트만 발생한다.

## Computer System Architecture
### Single-Processor 
하나의 메인 CPU만 탑재되어 있다. 장치에 따라 특정 목적을 수행하는 프로세서가 있어 디스크 프로세서는 디스크 연산만, 키보드 프로세서는 키보드 연산만 수행한다.

### Multi-Processor
2개 이상의 프로세서를 가지고 있다.
- 처리량 증가 
- 규모의 경제 : 여러 대의 싱글 프로세서 시스템보다 경제적이다.
- 신뢰성 증가 : 하나의 프로세스 장애에도 작업을 유지할 수 있어 fault-tolerant하다.

멀티 프로세서 시스템의 CPU들은 각각 레지스터와 캐시를 갖고 있다. 

CPU가 늘어나면 프로세서 간에 통신하는데 비효율성이 발생할 수 있다. 이를 해결하기 위해 하나의 칩에 여러 개의 코어를 갖는 **멀티코어(Multicore)**를 사용한다.
코어는 동일 성능의 CPU 여러 개를 1개의 칩 속에 집합한 것으로 칩 내부 통신으로 보다 효율적인 통신이 가능하다.

**클러스터 시스템**은 여러 독립적인 시스템이 모여 하나로 통합한 구조이다. 일반적으로 클러스터 컴퓨터는 하나의 저장소를 공유하고, LAN과 같은 네트워크로 연결된다. 
- 비대칭 클러스터 : 하나의 장비는 상시 대기( Hot-standby ) 모드로, 다른 노드를 모니터링한다. 다른 서버에 장애 발생 시 해당 노드가 작동하게 된다. 
- 대칭 클러스터 : 두 개 이상의 노드가 작업을 수행하면서 다른 노드들을 모니터링한다. 보다 효율적인 자원 사용이 가능하다.

## OS 구조
**멀티 프로그래밍**은 여러 프로그램을 메모리에 올려노고 작업 중인 프로세스가 대기 상태가 되면 다른 프로세스 작업을 수행하는 시스템이다.
**시분할 시스템**은 멀티 태스킹이라고 하며, 프로세스마다 작업 시간을 정해 돌아가면서 실행한다. 

여러 프로그램을 메모리에 로드하는 방식들이기에, **작업 스케줄링**을 통해 작업에 대한 우선순위를 설정한다. 메모리를 너무 많이 사용할 경우 반응 시간을 줄이기 위해 가상 메모리를 사용하게 된다.

### Process 관리
프로그램은 디스크 상에 존재하고, 메모리에 로드되면 프로세스가 된다. 프로세스는 실행된 위치를 저장하기 위한 Program Counter를 사용한다.
**싱글 스레드** 프로세스는 하나의 프로그램 카운터가 있고, **멀티 스레드** 프로세스는 여러 프로그램 카운터를 갖게 된다.

### Memory 관리
메인 메모리는 바이트의 배열이라며 각 바이트는 각각의 주소를 갖고 있다. 프로그램이 실행되면 절대 주소로 매핑되어 메모리에 로드된다.

### Storage 관리
- File-System 
- Mass-Storage : 제3의 저장 장치를 많이 사용하는데, 저장 장치는 WORM(Write-Once, Read-Many)과 RW(Read-Write) 형식 간에 차이가 존재한다. NTFS, FAT은 파일 저장 형식이며, 파일 시스템이라고 한다.
- Caching : 캐싱은 지역성( Locality ) 원리를 통해 캐시 메모리를 사용하여 속도를 높이다. **시간지역성(Temporal Locality)**은 한 번 접근한 데이터에 다시 접근할 확률이 높음을 의미하고, **공간지역성(Spatial Locality)**은 가까운 메모리 주소의 인접한 데이터에 접근할 가능성이 높음을 의미한다.

### I/O
운영체제는 모든 입출력장치를 파일로 취급하여 **장치 드라이버**만이 장치에 대한 정보를 갖고 있다.

# [Ch.2](https://parksb.github.io/article/6.html)

## OS services
- UI
- 프로그램 실행
- 입출력 명령
- 파일 시스템 조작
- 통신 : 공유 메모리( 여러 프로세스가 메모리의 한 부분을 공유 ) 또는 메시지 패싱( 프로세스 간 정보 패킷을 주고 받음 )을 통해 프로세스 간에 정보 교환
- 에러 탐지 
- 자원 할당 : 여러 사용자에게 자원을 잘 배분하도록 관리한다.
- 회계 : 누가 리소스를 얼마나 사용하는지 모니터링
- 보호 및 보안

## System Calls
**시스템 콜**은 커널과 사용자 프로그램을 이어주는 인터페이스 역할을 하며, 시스템에 접근하기 위해 커널 모드로 전환될 때 사용된다.
`fopen()`함수를 호출한다면, 파일을 여는 함수를 사용하기 위해 메모리 주소의 모음인 시스템 콜 테이블을 참조한다. 이외에 `fork()`, `exit()`, `read()`, `write()` 같은 함수가 있다.

사용자 프로그램 -> OS에 매개 변수를 넘기는 방법에는 아래와 같이 있다.
- call by value : 매개 변수 값을 복사하여 CPU 레지스터에 전달
- call by reference : 매개 변수 값의 메모리 주소를 전달
- stack에 매개변수가 추가되고, OS가 값을 뺀다.

## OS structure
- simple : 계층이 구분되어 있지 않다.
- layered approach : 가장 아래 계층이 하드웨어가 위치하고, 가장 높은 계층은 UI가 제공된다.
- microkernels : 마이크로커널은 커널에서 핵심적인 요소만 남기는 구조이다. 
- modules : 모듈은 커널은 확장하기 위한 구조로, 장치 드라이버는 모듈로 구현되어 있다. ex: 윈도우의 .dll파일
- hybrid system : OS 구조의 최신판으로, 커널의 핵심만 남기고 나머지 기능은 따로 구현한다. 

# [Ch.3](https://parksb.github.io/article/7.html)

프로세스는 stack/heap/data/code로 구성된다.
## process state
프로세스 상태는 다음과 같다.
- New : 프로세스 처음 생성됨
- Ready : 프로세스가 프로세서 할당을 대기
- Running : 프로세스가 할당되어 실행
- Waiting : 프로세스가 이벤트를 대기
- Terminated : 프로세스 실행 완료

## PCB(Process Control Block)
각각의 프로세스에는 아래와 같은 정보가 담긴 PCB를 포함하고 있다.
- 프로세스 상태
- 프로그램 카운터 : 프로세스가 이어서 실행할 명령의 주소를 담은 카운터
- CPU 레지스터 : 프로세스가 인터럽트 후에 작업을 이어가기 위한 CPU 레지스터 값
- CPU 스케줄링 정보 : 프로세스의 중요도, 스케줄링 큐 포인터 등 스케줄링 정보
- 메모리 정보
- 회계 정보(CPU 사용량, 프로세스 갯수 등)
- 입출력 정보(프로세스에 할당된 입출력 장치나 열린 파일 목록 등)

## Process Scheduling
프로세스 스케줄링은 어떤 프로세스를 프로세서에 할당할 것인지 결정하여 멀티프로그래밍과 타임쉐어링이 가능하도록 한다.

### Scheduling Queue
- Job queue : 프로세스가 시스템에 진입
- Ready queue : 메인 메모리에서 실행을 대기
- Device queue : 입출력 장치 대기

### Scheduler
- Job scheduler( Long-term scheduler ) : Ready queue -> 프로세스로 옮기는 작업
- CPU scheduler( Short-term scheduler ) : 프로세스를 프로세서에 할당하는 작업 

## Context Switch
**Context Switch**란 인터럽트 발생으로 OS가 개입하여 프로세서에 할당된 프로세스를 바꾸는 것을 의미한다. 여기서 광범위한 의미의 context란 시스템에서 활용 가능하며, 모니터링된 정보를 뜻하고 프로세서 관점에서 context=PCB이기에, PBC 정보가 바뀌는 것을 뜻한다.

## IPC(Interprocess Communication)

### Message passing
송수신 프로세스 간에 커널을 통해 정보를 전달하는 방식인데, context switch가 발생하기에 속도가 다소 느리다. 

### Shared memory
메모리 공간의 한 부분을 여러 프로세스가 공유하여 사용한다. 커널을 거치지 않기에 속도가 빠르지만, 메모리의 동시 접근 방지를 위한 규칙이 필요하다.

### Producer-Consumer problem
- producer : 정보를 생산하는 프로세스
- consumer : 정보를 소비하는 프로세스

Producer-Consumer problem은 위의 두 프로세스가 동시에 동작할 때 일어나는 문제를 의미한다. 정보를 생산하는 속도가 소비하는 속도보다 빠르기에, 버퍼를 사용하는 경우를 일컫는다.

### 동기화
message passing에서 동기화 문제를 해결하기 위한 몇 가지 방식이 있다.
- blocking send
- blocking receive
- non-blocking send
- non-blocking receive

## Pipe
**pipe**란 부모 프로세스와 자식 프로세스가 정보를 주고 받을 때 사용하는 방식이다. 단방향 통신만 가능하기에 양방향 통신의 경우 2개의 파이프가 필요하다. named pipe는 부모-자식 프로세스 관계가 아닌 경우에도 사용이 가능하다.

# [Ch.4](https://parksb.github.io/article/8.html)

## Threads
**싱글스레드**란 하나의 프로세스가 한번에 하나의 작업만 수행하는 것을 의미하고, **멀티스레드**는 하나의 프로세스가 동시에 여러 작업을 수행하는 것을 의미한다.

### 멀티프로그래밍 대신 멀티스레드를 쓰는 이유
- 두 프로세스가 데이터를 공유하려면 message passing, pipe 또는 shared memory를 사용해야 하는데 효율성이 떨어진다.
- 프로세스 간의 context switch가 자주 발생하면 성능 저하가 야기된다.

### 동시성 vs. 병렬성
- 동시성 : 프로세서가 *여러 개의 스레드*를 번갈아하며 수행하는 방식
- 병렬성 : *여러 개의 코어*가 각 스레드를 동시에 수행하는 방식으로 멀티코어 시스템에서 사용

### Multithreading Model
**User Threads**는 스레드가 사용자 수준의 스레드 라이브러리에 의해 관리되고, **Kernel Threads**는 커널에서 지원되는 스레드이다.
User thread와 Kernel thread간의 관계를 설계하는 방법에 몇 가지가 존재한다.

#### Many-to-One model
유저 스레드 : 커널 스레드 = N : 1관계이다. 한 번에 하나의 유저 스레드만 커널에 접근이 가능하기에 멀티코어 시스템에서 병렬 수행이 불가하다.
#### One-to-One model
유저 스레드 : 커널 스레드 = 1 : 1관계이다. 멀티프로세서 시스템에서 동시에 여러 스레드 수행이 가능하나, 유저 스레드에 따라 비례적으로 커널 스레드가 늘어가 성능 저하가 발생할 수 있다.
#### Many-to-Many model
유저 스레드 : 커널 스레드 = N : N관계이다. 유러저 스레드보다 적거나 같은 수의 커널 스레드가 생성된다.
#### Two-level model
유저 스레드 : 커널 스레드 = N : 1관계이며, 특정 유저 스레드를 위한 커널 스레드가 제공된다.

### Thread Pools
스레드를 요청할 때마다 생성하면 성능이 저하되기에 미리 스레드 풀을 생성하여 해당 풀에서 스레드를 할당하는 방식이다.

# [Ch.5](https://parksb.github.io/article/9.html)
프로세스 스케줄링은 운영체제가 어떤 프로세스를 프로세서에 할당할 것(Dispatch라고 함)인지 결정한다.  
*선점 방식*은 운영체제가 강제로 프로세스를 통제하는 방식이고, *비선점 방식*은 프로세스가 자체적으로 다음 프로세스에 넘겨주는 방식이다.

## Scheduling Type
### FCFS
- First Come Fist Served : 먼저 들어온 프로세스를 먼저 할당한다.
- Convoy effect : 수행 시간이 긴 프로세스가 먼저 들어오면 뒤에 따르는 프로세스의 대기 시간이 커진다.
- 먼저 온 프로세스가 끝날 때까지 운영체제가 개입하지 않는 비선점 스케줄링이다.

### SJF
- Shorted Job First : 프로세스의 수행시간이 짧은 순대로 프로세서에 할당한다.
- Convoy effect는 해결 가능하나, Burst 시간이 길면 계속 뒤로 밀려나는 Starvation이 발생한다.
- Burst 시간이 짧은 프로세스가 끝날 때까지 운영체제가 개입하지 하는 비선점 스케줄링이다.

### SRF
- Shortest Remaining time First : 프로세스의 남은 수행 시간이 짧은 순서대로 할당한다.
- Starvation 해결 가능
- 프로세스 수행 중 수행 시간이 다른 프로세스보다 짧은 프로세스가 생기면 운영체제가 개입하여 할당시키는 선점 스케줄링이다.

### RR
- Round Robin : 시간 할당량만큼 프로세스를 번갈아가며 할당한다.
- 주로 우선순위 스케줄링과 결합하여 프로세스의 시간 할당량을 조절하며 사용된다.
- 시간 할당량에 따라 운영체제가 개입하여 할당시키는 선점 스케줄링이다.

### Priority Scheduling
- 프로세스에 우선순위를 부여하여 순위에 따라 할당한다.
- 다른 스케줄링 알고리즘과 결합하여 사용이 가능하여 선점, 비선점 스케줄링이 가능하다.

# [Ch.6](https://parksb.github.io/article/10.html)
프로세스가 동시에 실행될 때 데이터가 동기화되지 않는 문제가 있을 수 있다. *Race Condition*은 프로세스가 데이터에 접근하는 순서에 따라 결과가 달라질 수 있는 상황을 의미한다.

## Critical-Section
*critical-section*이란 코드에서 Race Condition이 발생할 수 있는 구간을 의미한다.
critical section 문제를 해결하기 위해서 아래 조건을 따라야 한다.
- Mutual Exclution : critical section에 프로세스가 작업 중이라면 다른 프로세스가 개입할 수 없다.
- Progress : critical section에서 작업하는 프로세스가 없다면 다른 프로세스가 진입할 수 있다.
- Bounded Waiting : critical section에 프로세스가 진입하는데 무한정 대기하지 않는다.

